//=======================================================================
// Copyright Baptiste Wicht 2011.
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
//  http://www.boost.org/LICENSE_1_0.txt)
//=======================================================================

#include "NativeBackEnd.hpp"
#include "Utils.hpp"
#include "Options.hpp"
#include "AssemblyFileWriter.hpp"
#include "Assembler.hpp"
#include "FloatPool.hpp"

//Low-level Three Address Code
#include "ltac/Compiler.hpp"
#include "ltac/PeepholeOptimizer.hpp"
#include "ltac/Printer.hpp"
#include "ltac/aggregates.hpp"
#include "ltac/prologue.hpp"
#include "ltac/stack_offsets.hpp"
#include "ltac/register_allocator.hpp"
#include "ltac/pre_alloc_cleanup.hpp"

//Code generation
#include "asm/CodeGeneratorFactory.hpp"

using namespace eddic;

void NativeBackEnd::generate(std::shared_ptr<mtac::Program> mtac_program, Platform platform){
    std::string output = configuration->option_value("output");

    //Prepare the float pool
    auto float_pool = std::make_shared<FloatPool>();

    //Allocate stack positions for aggregates that have not been allocated
    ltac::allocate_aggregates(mtac_program);

    //Generate LTAC Code
    ltac::Compiler ltacCompiler(platform, configuration);
    ltacCompiler.compile(mtac_program, float_pool);

    //Switch to LTAC Mode
    mtac_program->mode = mtac::Mode::LTAC;

    //Clean the code generated by the LTAC Compiler to ease the register allocation
    ltac::pre_alloc_cleanup(mtac_program);
    
    if(configuration->option_defined("ltac-pre")){
        ltac::Printer printer;
        printer.print(mtac_program);
    }

    //Allocate pseudo registers into hard registers
    ltac::register_allocation(mtac_program, platform);
    
    //Generate the prologue and epilogue of each functions
    ltac::generate_prologue_epilogue(mtac_program, configuration);

    //If specified by the configuration, replace all stack offsets using SP 
    if(configuration->option_defined("fomit-frame-pointer")){
        ltac::fix_stack_offsets(mtac_program, platform);
    }
    
    if(configuration->option_defined("ltac-alloc")){
        ltac::Printer printer;
        printer.print(mtac_program);
    }

    if(configuration->option_defined("fpeephole-optimization")){
        ltac::optimize(mtac_program, platform);
    }

    if(configuration->option_defined("ltac") || configuration->option_defined("ltac-only")){
        ltac::Printer printer;
        printer.print(mtac_program);
    }

    if(!configuration->option_defined("ltac-only")){
        auto input_file_name = configuration->option_value("input");
        auto asm_file_name = input_file_name + ".s";
        auto object_file_name = input_file_name + ".o";

        //Generate assembly from TAC
        AssemblyFileWriter writer(asm_file_name);

        as::CodeGeneratorFactory factory;
        auto generator = factory.get(platform, writer, mtac_program->context);

        //Generate the code from the LTAC Program
        generator->generate(mtac_program, get_string_pool(), float_pool); 

        //Write the output
        writer.write(); 

        //If it's necessary, assemble and link the assembly
        if(!configuration->option_defined("assembly")){
            assemble(platform, asm_file_name, object_file_name, output, configuration->option_defined("debug"), configuration->option_defined("verbose"));

            //Remove temporary files
            if(!configuration->option_defined("keep")){
                remove(asm_file_name.c_str());
            }

            remove(object_file_name.c_str());
        }
    }
}
